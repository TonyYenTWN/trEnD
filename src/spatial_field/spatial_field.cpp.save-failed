// Main source file for inference of spatial fields
#include "src/spatial_field/spatial_field.h"

void spatial_field::BME_copula(inference_inform &inform, power_network::network_inform &Power_network_inform, Eigen::SparseMatrix <double> &Constraint, double tol){
	int bz_num = Constraint.cols();
	int point_num = Constraint.rows();

	// Iterations
	int count = 0;
	Eigen::VectorXd dmu = Eigen::VectorXd::Constant(point_num, 1.);
	while(count < 5000 && dmu.lpNorm<Eigen::Infinity>() > tol){
		// Matrices for the linear system
		Eigen::SparseMatrix <double> Conversion_Mat_1(point_num, point_num);
		std::vector <Eigen::TripletXd> Conversion_Mat_1_Trip;
		Conversion_Mat_1.reserve(point_num);

		for(int item = 0; item < point_num; ++ item){
			double diff_x = .5 * inform.mu_scale(item) * pow((-log(1. - cdf(inform.norm_dist, inform.x(item)))), -.5) * pow(1. - cdf(inform.norm_dist, inform.x(item)), -1.) * pdf(inform.norm_dist, inform.x(item));
			Conversion_Mat_1_Trip.push_back(Eigen::TripletXd(item, item, diff_x));
		}
		Conversion_Mat_1.setFromTriplets(Conversion_Mat_1_Trip.begin(), Conversion_Mat_1_Trip.end());

		Eigen::SparseMatrix <double> Conversion_Mat_2 = Conversion_Mat_1 * Constraint;

		// Solve the linear system
		Eigen::SparseLU <Eigen::SparseMatrix <double>, Eigen::COLAMDOrdering<int>> solver;
		solver.compute(Conversion_Mat_2.transpose() * Power_network_inform.points.covariance * Conversion_Mat_2);
		Eigen::VectorXd lambda = solver.solve(inform.mu_mean - Constraint.transpose() * inform.mu + Conversion_Mat_2.transpose() * inform.x);
		Eigen::VectorXd dx = Power_network_inform.points.covariance * Conversion_Mat_2 * lambda - inform.x;
		inform.x += inform.alpha_iteration * dx;

		// Update the solution
		for(int item = 0; item < point_num; ++ item){
			dmu(item) = inform.mu_scale(item) * pow(-log(1. - cdf(inform.norm_dist, inform.x(item))), .5) - inform.mu(item);
			inform.mu(item) += dmu(item);
		}
		Eigen::VectorXd mu_inv_0 = pow(inform.mu.array(), -1.);
		dmu *= mu_inv_0;

		count += 1;
	}
}

void spatial_field::BME_linear(inference_inform &inform, Eigen::SparseMatrix <double> &Constraint){
	// ---------------------------------------------------------------------
	// MaxEnt, known covariance and mean = 0, reference equiprobable space = x
	// COV^(-1) * x* - Constraint * lambda = 0
	// x* = COV * Constraint * lambda
	// Constraint^T * x* = Constraint^T * COV * Constraint * lambda = demand
	// lambda = solve(Constraint^T * COV * Constraint, demand)
	// ---------------------------------------------------------------------
	// Solve the linear system
	Eigen::VectorXd Constraint_sum = (inform.mu_scale.transpose() * Constraint).transpose();
	Eigen::SparseLU <Eigen::SparseMatrix <double>, Eigen::COLAMDOrdering<int>> solver;
	Eigen::VectorXd rhs = inform.mu_mean;
	std::cout << rhs << "\n\n";
	rhs -= Constraint_sum;
	std::cout << rhs << "\n\n";
//	Eigen::VectorXd lambda = solver.solve(rhs);
}

//void spatial_field::imbalance_inference(inference_inform &nominal_demand, power_network::network_inform &Power_network_inform){
//	int bz_num = Power_network_inform.points.bidding_zone.maxCoeff() + 1;
//	int point_num = Power_network_inform.points.bidding_zone.size();
//	int Time = power_market::parameters::Time();
//
//	// Read actual imbalance data
//	std::string fin_imbalance = "csv/input/power_market/control_reserve_activated_2021.csv";
//	auto fin_imbalance_dim = basic::get_file_dim(fin_imbalance);
//	auto Imbalnce_ts = basic::read_file(fin_imbalance_dim[0], fin_imbalance_dim[1], fin_imbalance);
//
//	// Set sparse matrix for equality constaints
//	Eigen::SparseMatrix <double> Constraint (point_num, bz_num);
//	std::vector<Eigen::TripletXd> Constraint_Trip;
//	Constraint_Trip.reserve(point_num);
//	for(int point_iter = 0; point_iter < point_num; ++ point_iter){
//		int bz_ID = Power_network_inform.points.bidding_zone(point_iter);
//		double value = nominal_demand.mu(point_iter) * Power_network_inform.points.population_density(point_iter) * Power_network_inform.points.point_area;
//		Constraint_Trip.push_back(Eigen::TripletXd(point_iter, bz_ID, value));
//	}
//	Constraint.setFromTriplets(Constraint_Trip.begin(), Constraint_Trip.end());
//
//	// ------------------------------------------------------------------------------------------------------------------------------------------
//	// Infer the annual average of the normalized mean demand field
//	// ------------------------------------------------------------------------------------------------------------------------------------------
//	// Initialization of parameters
//	inference_inform imbalance;
//	imbalance.alpha_iteration = 1.;
//	imbalance.mu_mean = Imbalnce_ts.colwise().sum().tail(bz_num);
//	imbalance.mu_mean /= Time;
//
//	// Inference step
//	BME_linear(nominal_demand, Constraint);
//}

void spatial_field::spatial_field_inference(power_network::network_inform &Power_network_inform){
	int bz_num = Power_network_inform.points.bidding_zone.maxCoeff() + 1;
	int point_num = Power_network_inform.points.bidding_zone.size();
	int Time = power_market::parameters::Time();
	double pi = boost::math::constants::pi<double>();

	// Read electricity demand data
	std::string fin_demand = "csv/input/spatial_field/demand_actual_2021.csv";
	auto fin_demand_dim = basic::get_file_dim(fin_demand);
	auto Demand_ts = basic::read_file(fin_demand_dim[0], fin_demand_dim[1], fin_demand);

	// Read actual imbalance data
	std::string fin_imbalance = "csv/input/power_market/control_reserve_activated_2021.csv";
	auto fin_imbalance_dim = basic::get_file_dim(fin_imbalance);
	auto Imbalnce_ts_raw = basic::read_file(fin_imbalance_dim[0], fin_imbalance_dim[1], fin_imbalance);
	Eigen::MatrixXd Imbalnce_ts(Time, bz_num);
	for(int zone_iter = 0; zone_iter < bz_num; ++ zone_iter){
		Imbalnce_ts.col(zone_iter) = Imbalnce_ts_raw.col(2 * zone_iter) - Imbalnce_ts_raw.col(2 * zone_iter + 1);
	}

	// Set sparse matrix for equality constraints for nominal demand
	Eigen::SparseMatrix <double> Constraint_demand (point_num, bz_num);
	std::vector<Eigen::TripletXd> Constraint_demand_Trip;
	Constraint_demand_Trip.reserve(point_num);
	for(int point_iter = 0; point_iter < point_num; ++ point_iter){
		int bz_ID = Power_network_inform.points.bidding_zone(point_iter);
		double value = Power_network_inform.points.population_density(point_iter) * Power_network_inform.points.point_area;
		Constraint_demand_Trip.push_back(Eigen::TripletXd(point_iter, bz_ID, value));
	}
	Constraint_demand.setFromTriplets(Constraint_demand_Trip.begin(), Constraint_demand_Trip.end());

	// ------------------------------------------------------------------------------------------------------------------------------------------
	// Infer the annual average of the normalized mean demand field
	// ------------------------------------------------------------------------------------------------------------------------------------------
	// Initialization of parameters
	inference_inform nominal_demand;
	nominal_demand.alpha_iteration = 1.;
	nominal_demand.mu_mean = Demand_ts.colwise().sum().tail(bz_num);
	nominal_demand.mu_mean /= Time;
	// Mean of weibull distribution = mu_0_scale * gamma(1 + 1 / k), here k = 2
	double mu_0_scale = nominal_demand.mu_mean.sum() / Constraint_demand.sum() * 2. / pow(pi, .5);
	nominal_demand.mu_scale = Eigen::VectorXd::Constant(point_num, mu_0_scale);
	nominal_demand.mu = Eigen::VectorXd::Constant(point_num, mu_0_scale);
	nominal_demand.x = Eigen::VectorXd(point_num);
	for(int item = 0; item < point_num; ++ item){
		nominal_demand.x(item) = quantile(nominal_demand.norm_dist, 1. - exp(-pow(nominal_demand.mu(item) / nominal_demand.mu_scale(item), 2.)));
	}

	// Inference step
	BME_copula(nominal_demand, Power_network_inform, Constraint_demand, 1E-12);

	// Output the annual average of normalized mean demand field
	std::string fout_name;
	fout_name = "csv/processed/spatial_field/nominal_mean_demand_field_10km_annual_mean.csv";
	std::vector <std::string> col_name;
	col_name.push_back("nominal_mean_demand");
	basic::write_file(nominal_demand.mu, fout_name, col_name);

	// Set sparse matrix for equality constraints for imbalance
	// must come after nominal demand!!
	Eigen::SparseMatrix <double> Constraint_imbalance (point_num, bz_num);
	std::vector<Eigen::TripletXd> Constraint_imbalance_Trip;
	Constraint_imbalance_Trip.reserve(point_num);
	for(int point_iter = 0; point_iter < point_num; ++ point_iter){
		int bz_ID = Power_network_inform.points.bidding_zone(point_iter);
		double value = nominal_demand.mu(point_iter) * Power_network_inform.points.population_density(point_iter) * Power_network_inform.points.point_area;
		Constraint_imbalance_Trip.push_back(Eigen::TripletXd(point_iter, bz_ID, value));
	}
	Constraint_imbalance.setFromTriplets(Constraint_imbalance_Trip.begin(), Constraint_imbalance_Trip.end());

	// ------------------------------------------------------------------------------------------------------------------------------------------
	// Infer the annual average of the imbalance field
	// ------------------------------------------------------------------------------------------------------------------------------------------
	// Initialization of parameters
	inference_inform imbalance;
	imbalance.alpha_iteration = 1.;
	imbalance.mu_mean = Imbalnce_ts.colwise().sum().tail(bz_num);
	imbalance.mu_mean /= Time;
	mu_0_scale = imbalance.mu_mean.sum() / Constraint_imbalance.sum();
	imbalance.mu_scale = Eigen::VectorXd::Constant(point_num, mu_0_scale);
	imbalance.Conversion_Mat_1 = Constraint_imbalance.transpose() * Power_network_inform.points.covariance * Constraint_imbalance;
	imbalance.Conversion_Mat_2 = Power_network_inform.points.covariance * Constraint_imbalance;

	// Inference step
	BME_linear(nominal_demand, Constraint_imbalance);

	// ------------------------------------------------------------------------------------------------------------------------------------------
	// Infer the normalized mean demand field
	// ------------------------------------------------------------------------------------------------------------------------------------------
	// Initialization of parameters
	nominal_demand.alpha_iteration = .01;
	nominal_demand.mu_scale = nominal_demand.mu * 2. / pow(pi, .5);
	nominal_demand.x_scale = Eigen::VectorXd(point_num);
	for(int item = 0; item < point_num; ++ item){
		nominal_demand.x_scale(item) = quantile(nominal_demand.norm_dist, 1. - exp(-pow(1., 2.)));
	}
	nominal_demand.mu = nominal_demand.mu_scale;
	nominal_demand.x = nominal_demand.x_scale;

	// Run the algorithm for each time slice
	for(int tick = 0; tick < 1; ++ tick){
		nominal_demand.mu_mean = Demand_ts.row(tick).tail(bz_num);

		// Inference step
		BME_copula(nominal_demand, Power_network_inform, Constraint_demand, 1E-3);

		// Output normalized mean demand field
		int count_zeros = 0;
		int tick_temp = tick;
		std::string digit_zeros;
		while(int (tick_temp / 10) != 0){
			count_zeros += 1;
			tick_temp /= 10;
		}
		for(int item = 0; item < 5 - count_zeros; ++item){
			digit_zeros += std::to_string(0);
		}
		fout_name = "csv/processed/spatial_field/nominal_mean_demand_field_10km_ts_" + digit_zeros + std::to_string(tick) + ".csv";
		basic::write_file(nominal_demand.mu, fout_name, col_name);
		digit_zeros.clear();
	}
}

// Function that stores processed mean demand field
void spatial_field::spatial_field_store(power_network::network_inform &Power_network_inform, std::string fin_demand, int Time){
	int row_num = Power_network_inform.points.bidding_zone.rows();
	Power_network_inform.points.nominal_mean_demand_field = Eigen::MatrixXd(row_num, Time);

	//for(int tick = 0; tick < Time; ++ tick){
	for(int tick = 0; tick < 100; ++ tick){
		// Find zeros before the number
		int count_zeros = 0;
		int tick_temp = tick;
		std::string digit_zeros;
		while(int (tick_temp / 10) != 0){
			count_zeros += 1;
			tick_temp /= 10;
		}
		for(int item = 0; item < 5 - count_zeros; ++item){
			digit_zeros += std::to_string(0);
		}

		// File name with enumeration
		std::string fin_demand_temp = fin_demand + digit_zeros + std::to_string(tick) + ".csv";

		Power_network_inform.points.nominal_mean_demand_field.col(tick) = basic::read_file(row_num, 1, fin_demand_temp);
	}
}
